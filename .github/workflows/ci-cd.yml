name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.nhprod.ru
  IMAGE_NAME: bidit-backend
  GO_VERSION: '1.25'

jobs:
  lint:
    name: Lint & Format
    runs-on: self-hosted
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      
      - name: Check gofmt
        run: |
          echo "Checking gofmt..."
          unformatted=$(gofmt -l .)
          if [ -n "$unformatted" ]; then
            echo "âŒ These files are not formatted:"
            echo "$unformatted"
            exit 1
          fi
          echo "âœ… All files are formatted correctly"
      
      - name: Run go vet
        run: |
          echo "Running go vet..."
          go vet ./...

  test:
    name: Run Tests
    runs-on: self-hosted
    needs: lint
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      
      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: |
          go test -v -coverprofile=coverage.out -covermode=atomic ./...
      
      - name: Generate coverage report
        run: |
          go tool cover -func=coverage.out
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo "ðŸ“Š Total coverage: $COVERAGE"
      
  build:
    name: Build & Push Image
    runs-on: self-hosted
    needs: test
    if: github. event_name != 'pull_request'
    
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_digest: ${{ steps.build.outputs. digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: false
        continue-on-error: true
      
      - name: Build Go binary
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
          go build -ldflags="-w -s" -o app ./cmd/app
          
          echo "âœ… Binary built successfully"
          ls -lh app
      
      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          
          if [ "${{ github. ref }}" == "refs/heads/main" ]; then
            IMAGE_TAG="${{ env. REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
            IMAGE_TAG_SHA="${{ env. REGISTRY }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}"
          else
            BRANCH=$(echo ${{ github.ref }} | sed 's/refs\/heads\///')
            IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH}-${SHORT_SHA}"
            IMAGE_TAG_SHA=""
          fi
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_tag_sha=${IMAGE_TAG_SHA}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image tag: ${IMAGE_TAG}"
          [ -n "${IMAGE_TAG_SHA}" ] && echo "ðŸ“¦ Additional tag: ${IMAGE_TAG_SHA}"
      
      - name: Install Docker CLI
        run: |
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker CLI..."
            curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-27.0.0. tgz | \
              tar xzf - --strip-components=1 -C /tmp docker/docker
            sudo mv /tmp/docker /usr/local/bin/docker
            sudo chmod +x /usr/local/bin/docker
          else
            echo "âœ… Docker already installed"
          fi
          docker --version
      
      - name: Login to registry
        run: |
          echo "${{ secrets.REGISTRY_PASSWORD }}" | \
            docker login \
              --username "${{ secrets. REGISTRY_USER }}" \
              --password-stdin \
              ${{ env.REGISTRY }}
      
      - name: Build image with Docker
        id: build
        run: |
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          
          docker build \
            --build-arg VERSION=${{ github.sha }} \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            --tag ${{ steps.meta. outputs.image_tag }} \
            --file Dockerfile \
            .
          
          if [ -n "${{ steps.meta.outputs.image_tag_sha }}" ]; then
            docker tag ${{ steps.meta.outputs.image_tag }} ${{ steps.meta.outputs.image_tag_sha }}
            echo "ðŸ“¦ Additional tag: ${{ steps.meta.outputs.image_tag_sha }}"
          fi
          
          echo "âœ… Image built successfully"
          
          IMAGE_ID=$(docker images -q ${{ steps.meta.outputs.image_tag }})
          echo "digest=${IMAGE_ID}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image ID: ${IMAGE_ID}"
      
      - name: Push image to registry
        run: |
          docker push ${{ steps.meta.outputs.image_tag }}
          echo "âœ… Pushed: ${{ steps.meta.outputs.image_tag }}"
          
          if [ -n "${{ steps.meta.outputs.image_tag_sha }}" ]; then
            docker push ${{ steps.meta.outputs.image_tag_sha }}
            echo "âœ… Pushed: ${{ steps.meta.outputs.image_tag_sha }}"
          fi
          
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.meta.outputs.image_tag }} | cut -d'@' -f2)
          echo "ðŸ“¦ Final digest: ${DIGEST}"
      
      - name: Cleanup
        if: always()
        run: |
          docker rmi ${{ steps.meta.outputs.image_tag }} 2>/dev/null || true
          [ -n "${{ steps.meta. outputs.image_tag_sha }}" ] && docker rmi ${{ steps.meta.outputs.image_tag_sha }} 2>/dev/null || true
          echo "âœ… Cleanup completed"
