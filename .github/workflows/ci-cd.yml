name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.nhprod.ru
  IMAGE_NAME: bidit-backend
  GO_VERSION: '1.23'
  DOCKER_VERSION: "27.5.0"

jobs:
  lint:
    name: Lint & Format
    runs-on: arc-runner-set
    
    container:
      image: golang:1.25-bookworm
      options: --user root
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Check gofmt
        run: |
          echo "ðŸ” Checking gofmt..."
          unformatted=$(gofmt -l .)
          if [ -n "$unformatted" ]; then
            echo "âŒ These files are not formatted:"
            echo "$unformatted"
            exit 1
          fi
          echo "âœ… All files are formatted correctly"
      
      - name: Run go vet
        run: |
          echo "ðŸ” Running go vet..."
          go vet ./... 
          echo "âœ… go vet passed"

  test:
    name: Run Tests
    runs-on: arc-runner-set
    needs: lint
    
    container:
      image: golang:1.25-bookworm
      options: --user root
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Go cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Download dependencies
        run: |
          echo "ðŸ“¥ Downloading dependencies..."
          go mod download
          echo "âœ… Dependencies downloaded"

      - name: Run tests
        run: |
          echo "ðŸ§ª Running tests..."
          go test -v -coverprofile=coverage.out -covermode=atomic ./...
          echo "âœ… Tests passed"
      
      - name: Generate coverage report
        run: |
          echo "ðŸ“Š Generating coverage report..."
          go tool cover -func=coverage.out
          COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“Š Total coverage: $COVERAGE"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
  build:
    name: Build & Push Image
    runs-on: arc-runner-set
    needs: test
    if: github.event_name != 'pull_request'
    
    services:
      docker:
        image: docker:24-dind
        options: >-
          --privileged
          --health-cmd "docker info"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        env:
          DOCKER_TLS_CERTDIR: ""
    
    container:
      image: golang:1.25-bookworm
      env:
        DOCKER_HOST: tcp://docker:2375
        DOCKER_DRIVER: overlay2
        DEBIAN_FRONTEND: noninteractive
      options: --user root
    
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Install Docker CLI and dependencies
        run: |
          apt-get update
          apt-get install -y curl ca-certificates
          apt-get clean
          rm -rf /var/lib/apt/lists/*
          
          echo "ðŸ“¥ Downloading Docker CLI ${DOCKER_VERSION}..."
          curl -fsSL "https://download.docker.com/linux/static/stable/x86_64/docker-${DOCKER_VERSION}.tgz" | \
            tar -xz -C /tmp
          
          echo "ðŸ“¦ Installing Docker CLI..."
          mv /tmp/docker/docker /usr/local/bin/docker
          chmod +x /usr/local/bin/docker
          rm -rf /tmp/docker
          
          echo "âœ… Docker CLI installed:"
          docker --version
      
      - name: Wait for Docker daemon
        run: |
          echo "â³ Waiting for Docker daemon to be ready..."
          for i in $(seq 1 30); do
            if docker info >/dev/null 2>&1; then
              echo "âœ… Docker daemon is ready"
              docker version
              break
            fi
            echo "   Attempt $i/30..."
            sleep 2
          done
          
          if !  docker info >/dev/null 2>&1; then
            echo "âŒ Docker daemon failed to start"
            exit 1
          fi
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify Go installation
        run: |
          echo "ðŸ¹ Go version:"
          go version
          echo ""
          echo "GOROOT=$(go env GOROOT)"
          echo "GOPATH=$(go env GOPATH)"
      
      - name: Setup Go cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-
      
      - name: Download dependencies
        run: |
          echo "ðŸ“¥ Downloading dependencies..."
          go mod download
          echo "âœ… Dependencies downloaded"
      
      - name: Build Go binary
        run: |
          echo "ðŸ”¨ Building Go binary..."
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
          go build -ldflags="-w -s -X main.version=${{ github.sha }} -X main.buildDate=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
          -o app ./cmd/app
          
          echo ""
          echo "âœ… Binary built successfully"
          ls -lh app
          file app
      
      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
            IMAGE_TAG_SHA="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}"
          else
            BRANCH=$(echo ${{ github.ref }} | sed 's/refs\/heads\///')
            IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${BRANCH}-${SHORT_SHA}"
            IMAGE_TAG_SHA=""
          fi
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_tag_sha=${IMAGE_TAG_SHA}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          
          echo "ðŸ·ï¸  Image tags:"
          echo "   - ${IMAGE_TAG}"
          [ -n "${IMAGE_TAG_SHA}" ] && echo "   - ${IMAGE_TAG_SHA}"
      
      - name: Login to registry
        run: |
          echo "ðŸ” Logging in to ${{ env.REGISTRY }}..."
          echo "${{ secrets.REGISTRY_PASSWORD }}" | \
            docker login \
              --username "${{ secrets.REGISTRY_USER }}" \
              --password-stdin \
              ${{ env.REGISTRY }}
          echo "âœ… Successfully logged in"
      
      - name: Build Docker image
        id: build
        run: |
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          
          echo "ðŸ”¨ Building Docker image..."
          echo "   Version: ${{ github.sha }}"
          echo "   Build date: ${BUILD_DATE}"
          echo ""
          
          docker build \
            --build-arg VERSION=${{ github.sha }} \
            --build-arg BUILD_DATE=${BUILD_DATE} \
            --tag ${{ steps.meta.outputs.image_tag }} \
            --file Dockerfile \
            . 
          
          if [ -n "${{ steps.meta.outputs.image_tag_sha }}" ]; then
            echo ""
            echo "ðŸ·ï¸  Tagging with SHA: ${{ steps.meta.outputs.image_tag_sha }}"
            docker tag ${{ steps.meta.outputs.image_tag }} ${{ steps.meta.outputs.image_tag_sha }}
          fi
          
          echo ""
          echo "âœ… Docker image built successfully"
          
          IMAGE_ID=$(docker images -q ${{ steps.meta.outputs.image_tag }})
          echo "digest=${IMAGE_ID}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image ID: ${IMAGE_ID}"
      
      - name: Push image to registry
        run: |
          echo "ðŸš€ Pushing ${{ steps.meta.outputs.image_tag }}..."
          docker push ${{ steps.meta.outputs.image_tag }}
          echo "âœ… Pushed successfully"
          
          if [ -n "${{ steps.meta.outputs.image_tag_sha }}" ]; then
            echo ""
            echo "ðŸš€ Pushing ${{ steps.meta.outputs.image_tag_sha }}..."
            docker push ${{ steps.meta.outputs.image_tag_sha }}
            echo "âœ… Pushed successfully"
          fi
          
          echo ""
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ steps.meta.outputs.image_tag }} 2>/dev/null | cut -d'@' -f2 || echo "N/A")
          echo "ðŸ“¦ Final digest: ${DIGEST}"
      
      - name: Image info
        run: |
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… Successfully pushed images:"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“¦ ${{ steps.meta.outputs.image_tag }}"
          if [ -n "${{ steps.meta.outputs.image_tag_sha }}" ]; then
            echo "ðŸ“¦ ${{ steps.meta.outputs.image_tag_sha }}"
          fi
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: Cleanup Docker
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up Docker resources..."
          docker rmi ${{ steps.meta.outputs.image_tag }} 2>/dev/null || true
          [ -n "${{ steps.meta.outputs.image_tag_sha }}" ] && docker rmi ${{ steps.meta.outputs.image_tag_sha }} 2>/dev/null || true
          docker system prune -f || true
          echo "âœ… Cleanup done"
